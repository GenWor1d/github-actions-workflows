name: 通用部署
on:
  workflow_call:
    inputs:
      branch:
        required: false
        type: string
        default: ${{ github.ref_name }}
      working-directory:
        required: false
        type: string
        default: 'deployment'
      env-file:
        description: 'Docker Compose 环境文件路径'
        required: false
        type: string
        default: ''

jobs:
  deploy:
    name: 部署${{ inputs.branch }}环境-${{ github.run_number }}
    runs-on: ${{ github.ref_name }}
    defaults:
      run:
        working-directory: ${{ inputs.working-directory }}
    
    steps:
      - name: 检出代码
        uses: actions/checkout@v4

      - name: 生成环境变量
        id: gen_env
        run: |
          echo "开始生成环境变量..."
          IMAGE_TAG="${{ inputs.branch }}-$(TZ='Asia/Shanghai' date +%Y%m%d-%H%M%S)"
          PROJECT_NAME=$(basename $GITHUB_WORKSPACE | tr '[:upper:]' '[:lower:]')
          
          echo "分支: ${{ inputs.branch }}"
          echo "项目名称: $PROJECT_NAME"
          echo "镜像标签: $IMAGE_TAG"

          # 保存默认环境变量到.env文件
          cat > $GITHUB_WORKSPACE/.env << EOF
          BRANCH_NAME=${{ inputs.branch }}
          PROJECT_NAME=$PROJECT_NAME
          IMAGE_TAG=$IMAGE_TAG
          CONTAINER_NAME=$PROJECT_NAME
          NETWORK_NAME=gen-world-bridge
          EOF
          
          # 如果提供了环境文件路径，则直接追加到.env文件（利用Docker Compose读取最后一个定义的特性实现覆盖）
          if [ -n "${{ inputs.env-file }}" ]; then
            echo "合并环境文件: ${{ inputs.env-file }}"
            cat ${{ inputs.env-file }} >> $GITHUB_WORKSPACE/.env
          fi
          
          # 从.env文件加载变量到环境中（供后续步骤使用）
          set -a
          source $GITHUB_WORKSPACE/.env
          set +a
          
          # 将变量保存到GITHUB_ENV供后续步骤使用
          grep -v '^#' $GITHUB_WORKSPACE/.env >> $GITHUB_ENV
          
          echo "环境变量文件已生成:"

      - name: 配置网络
        run: |
          docker network create ${{ env.NETWORK_NAME }} && echo "[INFO] 网络创建成功" || echo "[INFO] 网络已存在"

      - name: 执行预部署脚本
        run: |
          echo "项目名称: ${{ env.PROJECT_NAME }}"
          echo "镜像标签: ${{ env.IMAGE_TAG }}"
          
          # 检查预部署脚本文件
          PRE_DEPLOY_SCRIPT="./scripts/pre-deploy.sh"
          if [ -f "$PRE_DEPLOY_SCRIPT" ]; then
            echo "找到预部署脚本文件: $PRE_DEPLOY_SCRIPT"
            chmod +x "$PRE_DEPLOY_SCRIPT"
            "./$PRE_DEPLOY_SCRIPT"
          else
            echo "警告：预部署脚本文件不存在，跳过执行"
            echo "当前目录内容:"
            ls -la ./
          fi

      - name: 构建Docker镜像
        run: |
          echo "开始构建Docker镜像"
          docker compose --env-file $GITHUB_WORKSPACE/.env build
          echo "镜像构建完成"

      - name: 部署容器
        run: |
          echo "开始部署容器"
          echo "容器名称: ${{ env.CONTAINER_NAME }}"
          
          # 直接部署：使用docker compose down停止并删除旧容器，再启动新容器
          echo "停止并删除旧容器..."
          docker compose down --remove-orphans || echo "旧容器不存在或已停止删除"
          
          echo "启动新容器..."
          docker compose --env-file "$GITHUB_WORKSPACE/.env" up -d
          
          # 等待容器启动
          echo "等待容器启动并检查健康状态..."
          sleep 5
          
          echo "打印容器日志:"
          docker logs "${{ env.CONTAINER_NAME }}"
          
          echo "部署完成"

      - name: 清理镜像
        run: |
          echo "开始清理Docker镜像..."

          IMAGES_TO_REMOVE=$(docker images --format "{{.Repository}}:{{.Tag}}" | grep "^${{ env.PROJECT_NAME }}:${{ env.BRANCH_NAME }}-" | sort -r | tail -n +3)
          
          if [ -n "$IMAGES_TO_REMOVE" ]; then
            echo "将清理以下镜像："
            echo "$IMAGES_TO_REMOVE"
            
            # 逐个删除镜像，失败则跳过
            for IMAGE in $IMAGES_TO_REMOVE; do
              echo "清理镜像: $IMAGE"
              docker rmi $IMAGE || echo "删除镜像 $IMAGE 失败，跳过"
            done
          else
            echo "没有需要清理的镜像"
          fi
          
          echo "镜像清理完成"